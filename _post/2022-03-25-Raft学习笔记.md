---
layout: post
author: yujing
---

隔离级别：在数据库正确性和性能间做tradeoff



一致性级别：分布式数据库中，也是在数据库正确性和性能间做tradeoff

**一致性**的定义基本上取决于上下文。一般而言，一致性是指系统确保其遵守（不会失败）一组预定义规则的能力。但是，这组规则会根据上下文而变化。例如，ACID 的 C 和 CAP 的 C 都指一致性。然而，这两种情况所隐含的规则集是完全不同的。在 ACID 中，规则是指应用程序定义的语义。保证 ACID 的 C 的系统可确保处理事务不会违反参照完整性约束、外键约束和任何其他特定于应用程序的约束（例如：“每个用户都必须有一个名字”）。相比之下，CAP 的一致性 C 是指与使并发分布式系统看起来像单线程集中式系统相关的规则。

在这一点上我们可以消除的一个混淆点是“一致性级别”这个短语通常不用于 ACID 一致性的上下文中。这是因为 ACID 的 C 几乎完全是应用程序开发人员的责任 --- 只有开发人员才能确保他们放置在事务中的代码在隔离运行时不会违反应用程序语义。 

当我们谈论**一致性级别**时，我们实际上指的是 CAP 的 C。在这种情况下，完美一致性——通常称为“严格一致性”——意味着系统确保所有读取都反映所有先前的写入——无论这些写入是在哪里执行的。任何低于“完美”一致性的一致性级别都会导致读取不返回数据项的最新写入的情况发生。[旁注：[原始 CAP 论文](https://users.ece.cmu.edu/~adrian/731-sp04/readings/GL-cap.pdf)中 CAP 的 C指的是一种称为“原子一致性”的东西，它比严格一致性稍弱，但在实际应用中仍被认为是“完美的”。我们将在本文后面讨论差异。]



可串行化：系统所要做的就是确保事务在并发运行时，最终状态等同于它们串行运行时系统存在的状态。有几种方法可以实现这一点——例如通过锁定、验证或多版本控制

*可序列化隔离通常允许应用程序开发人员不必考虑并发性，而只专注于使单线程代码正确。*

可序列化的系统只保证事务将以与**某些事务等效的方式处理**串行顺序。可序列化保证本身不会对这个序列顺序施加任何限制。



脏写：T1写完未提交T2就写。w1(x) w2(x) c1

脏读：先写后读但写未提交，写可能回滚，那读的数据就是错误的。w1(x), r2(x), a1.

不可重复读：先读后写，T2在T1修改并提交之前读了同一数据项，且有可能再次读同一数据项。r1[x]...w2[x]...c2...r1[x]...c1 

幻读：两次范围查询之间，范围内写入了数据

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220226222923699.png" alt="image-20220226222923699" style="zoom:50%;" />

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220226223027803.png" alt="image-20220226223027803" style="zoom: 40%;" />



一致性级别历来是根据数据项的==单个==读取或写入来定义的

在**顺序一致性**，所有写入 --- 无论哪个线程进行写入，也无论写入哪个数据项 --- 都是全局排序的。每个执行线程都必须看到按此顺序发生的写入。（和时间无关）

与顺序一致性相比，**严格一致性** **确实**对如何排序写入提出了实时要求。 

它假设总是可以知道它当前是什么时间，并且零错误——即每个执行线程都同意精确的当前时间。顺序中的写入顺序必须等于发出这些写入的实时时间。此外，每个读取操作都必须实时读取最近写入的值——无论哪个执行线程启动了该写入。在分布式系统（甚至多处理器单服务器系统）中，实际上不可能就精确的当前时间达成全局一致，这使得严格一致性成为主要的理论兴趣。



在分布式/复制系统中，写入和读取可以起源于任何地方，实践中获得的最高一致性是**线性化**（也称为“原子一致性”，在 CAP 定理中称为“原子一致性”）。线性化与严格一致性非常相似：两者都是对写入施加实时约束的顺序一致性的扩展。不同之处在于，线性化模型承认在向系统提交操作到系统响应确认操作已完成之间存在一段时间。在分布式系统中，将写入请求发送到正确的位置（可能包括复制）可以在此时间段内发生。线性化保证不会对开始和结束**时间重叠**的操作施加任何排序约束。

> 虽然线性化和严格一致性强于顺序一致性，但顺序一致性本身就是一个非常高的一致性级别，在它之下还存在许多一致性级别。



在**顺序一致性**，所有写入 --- 无论哪个线程进行写入，也无论写入哪个数据项 --- 都是全局排序的。每个执行线程都必须看到按此顺序发生的写入。（和时间无关）



**因果一致性**是一种流行且有用的一致性级别，略低于顺序一致性。在顺序一致性中，所有写入都必须是全局排序的——即使它们彼此完全不相关。因果一致性不会强制无关写入的顺序。但是，如果一个执行线程读取某个数据项（称为 X），然后写入该数据项或另一个数据项（称为 Y），则它假定后续写入可能是由读取*引起的。*因此，它强制执行 X 和 Y 的顺序 --- 具体来说，所有执行线程必须在 X 写入之后观察 Y 的写入。

**最终的一致性**甚至更弱——甚至因果相关的写入也可能变得乱序可见。例如，尽管违反了我们迄今为止讨论的所有其他一致性保证，但图 6 并不一定违反最终一致性。最终一致性的唯一保证是，如果在“长”时间段内没有写入（其中“长”的定义取决于系统），每个执行线程都会就最后一次写入的值达成一致。



一致性级别历来是根据数据项的==单个==读取或写入来定义的

一致性图中事务的存在增加了与 ACID 的 AID 对应的附加约束：事务内的所有读取和写入一起成功或失败（原子性），它们与其他并发运行的事务隔离（隔离程度取决于在隔离级别上），并且已提交事务的写入将比各种系统故障（持久性）更长。







PSI:

评估性能：

![image-20220301222920103](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220301222920103.png)

![image-20220301230838111](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220301230838111.png)

![image-20220301231010216](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220301231010216.png)

![image-20220302115857917](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220302115857917.png)



1.动机   

2.背景（操作一致性级别、隔离级别） 多副本+事务   

3.SS等验证及实现 伪代码  

4.性能比较



![image-20220308100424919](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220308100424919.png)