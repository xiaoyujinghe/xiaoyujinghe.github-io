---
layout: post
author: yujing
---

## 探究一致性级别与隔离级别


无论是在学术界还是工业界，大家对于一致性和隔离性都存在混用的情况，但细究下来，两者之间的区别是很大的，却又都对数据库数据的正确性和完整性十分重要。下面将分别讨论一致性和隔离性的含义及不同的等级，然后再探究它们的区别与联系。

### 一、一致性级别

一致性有很多不同的含义，目前一致性主要分为多处理器编程中的数据一致性、语义上的数据一致性和数据副本的一致性，本文主要讨论语义上的数据一致性和数据副本的一致性。

1. #### 语义上的数据一致性

语义上的数据一致性在不同的场景下会有不同的要求，如确保数据的外键约束、特定应用程序的约束（例如：“每个用户都必须有一个名字”，“A的总金额+B的总金额=100”）。语义上的一致性也是ACID中的C，这种一致性是靠应用开发人员来保证的。

2. #### 数据副本的一致性

在分布式数据库中，强一致性意味着系统确保所有的读操作都能正确反映所有之前的写入，无论这些写入是在哪里执行的。任何低于强一致性的一致性级别都会导致读取不返回数据项的最新写入的情况发生。数据副本的一致性也是CAP理论中的C，本文中所讨论的一致性都为数据副本一致性。下面列举几种常见的一致性级别：

##### （1）线性一致性

线性一致性要求任何一次读都能读到某个数据的最近一次写的数据，并且统中的所有进程，看到的操作顺序，都和全局时钟下的顺序一致。

##### （2）顺序一致性

顺序一致性要求任何一次读都能读到某个数据的最近一次写的数据，并且系统的所有进程的顺序一致，而且是合理的。即不需要和操作实际发生的顺序一致，错的话一起错，对的话一起对。

##### （3） 因果一致性

因果一致性是一种流行且有用的一致性级别，略低于顺序一致性。在顺序一致性中，即使所有写入都不涉及同一数据项，但所有写入都必须是全局排序的。而因果一致性则放松了对无关写入的顺序要求。

##### （4）最终一致性

在最终一致性下，如果没有进一步更新，所有副本会收敛到相同的状态。也就是说，如果没有新的写操作，最终所有的读操作都将返回相同的值。

##### （5） 弱一致性

数据更新后，如果能容忍后续的访问只能访问到部分或者全部访问不到，则是弱一致性。弱一致性并不对数据有顺序上的要求。



### 二、 隔离级别

数据库事务的四大特性为：原子性（Atomicity），一致性（Consistency），隔离性（Isolation），持久性（Durability），简称ACID。我们所述的隔离即ACID中的隔离性，即在有多个事务并发时，事务之间不会相互破坏。事务隔离级别越高，数据的正确性和数据库的完整性也就越高，但是数据并发处理的效率也会有所降低。

在ANSI SQL92规范中，根据数据库允许数据发生的异常现象来定义隔离级别，共定义了4种异常：脏写（Dirty Write）、脏读（Dirty Read）、不可重复读（Non-Repeatable Read）、幻读（Phantom）。下面简述四种异常：

假设有两个并发事务分别为Transactioin1（T1）和Transaction2（T2）。

脏写就是当两个事务中都存在涉及到同一数据项的写操作时，就可能发生写写冲突，导致其中一个事务的更新被覆盖。这样的异常是严重的，因此在现实中任何一种隔离级别都必须禁止脏写异常。

脏读的情况为，T1正在写一个数据项时T2读了同一个数据项并读取到了T1所写的数据，此时若事务T1回滚，那T2所读的数据就是错误的。

不可重复读的异常较脏读异常的区别是，T2会在T1写某一数据前读取同一数据项，且在T1提交后又再次读取该数据项，由于T1已经更新了该数据项，所以T2两次读取到的数据可能是不同的。

幻读与不可重复读相似，但涉及到的是范围查询的场景，在T2前后两次范围查询之间，T1插入（或删除）了满足T2查询的数据项，导致T2前后两次范围查询的结果不同。

为了防止产生以上不同的异常，又定义了几种不同的隔离级别，如表1所示。

​													表1 常见隔离级别可能产生的异常

|          | 脏写 | 脏读 | 不可重复读 |   幻读    |
| :------: | :--: | :--: | :--------: | :-------: |
| 可串行化 |  NO  |  NO  |     NO     |    NO     |
| 快照隔离 |  NO  |  NO  |     NO     | SOMETIMES |
| 可重复读 |  NO  |  NO  |     NO     |    YES    |
| 读已提交 |  NO  |  NO  |    YES     |    YES    |
| 读未提交 |  NO  | YES  |    YES     |    YES    |

### 三、 一致性级别和隔离级别之间的关系

在分布式数据库系统中，通常会牺牲一定的正确性来达到更高的性能，一致性级别和隔离级别都是用于权衡正确性和性能的概念。本文2.1与2.2有提到，强一致性意味着系统确保所有的读操作都能正确反映所有之前的写入，无论这些写入是在哪里执行的；隔离级别引入事务（一系列操作的合集）的概念，指数据库允许事务像没有其他并发运行的事务一样执行的能力。一致性级别和隔离级别两者的概念是不同的，因此研究人员有必要弄清楚隔离级别与一致性级别的区别。对于开发人员，也需要更多地了解隔离级别和一致性级别之间的差异以及它们之间的关系，以便就如何权衡正确性和性能做出明智的决定。

分布式数据库隔离级别和一致性级别的一大区别是，隔离级别用于保证事务间的隔离性（并发的事务不会相互影响），而一致性级别用于保证事务间执行的顺序。只要有事务的存在，系统就必须保证一定的隔离性，并且明确告知用户可能发生的异常。如果没有隔离保证，那当大量事务并发时，必将涉及到脏写等异常，这是非常可怕的。那有了保证了一定的隔离级别，还需要一致性级别吗？答案是肯定的，让我们看一个例子，在两个线程P1、P2中，T1首先执行读取x=5并将x的值写为10，然后T2读取x=10并将x的值写为20，T3读取到的x的值为原始值5，由此推断三个事务实际执行顺序为T3、T1、T2，但是在P2中，T3一定发生在T2之后，违反了顺序一致性，在分布式和存在副本复制的系统中，这样的异常是严重的。这意味着所有时间旅行错误都可能在任何隔离级别上出现。隔离级别仅指定并发事务的发生的情况。如果两个事务没有同时运行，那就没有任何隔离保证会指定如何处理它们。这就是即使在最高级别的隔离下也可能出现时间旅行正确性错误的原因。如果想保证非并发事务的执行顺序，例如：确保后面的事务读取前面事务的写入，我们就需要一致性保证。